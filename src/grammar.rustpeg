use ast::*;

pub program -> Vec<Statement>
    = __ terminators? s:statements { s }

pub statements -> Vec<Statement>
    = sx:statement terminators s:statements { let mut sc = s.to_vec(); sc.insert(0, sx); sc }
    / sx:statement terminators { let mut v = vec![sx]; v }

statement -> Statement
    = a:assignment_statement { a }
    / v:variable_declaration { v }
    / e:expr { Statement::Expression(e) }
    / b:block { b }

assignment_statement -> Statement
    = i:identifier equals e:expr {
        Statement::Assignment(LhsExpr::Identifier(i), e)
    }

variable_declaration -> Statement
    = b:binding i:identifier a:type_annotation? equals e:expr {
        match a {
            Some(t) => Statement::VariableDeclaration(
                Variable::IdentifierWithType(b, i, t), e
            ),
            None => Statement::VariableDeclaration(
                Variable::Identifier(b, i), e
            )
        }
     }

binding -> Binding
    = VAR { Binding::Mutable }
    / VAL { Binding::Immutable }

block -> Statement
    = OPENING_BRACE terminators? s:statements terminators? CLOSING_BRACE { Statement::Block(s) }

expr -> Expr
    = e:binary_expr { e }
    / s:simple_expr { s }
    / i:identifier t:type_annotation { Expr::IdentifierWithType(i, t) }
    / i:identifier { Expr::Identifier(i) }

binary_expr -> Expr = #infix<simple_expr> {
    #L x OP_PLUS y { Expr::BinaryExpression(Box::new(x), BinaryOp::Add, Box::new(y)) }
       x OP_MINUS y { Expr::BinaryExpression(Box::new(x), BinaryOp::Sub, Box::new(y)) }
    #L x OP_ASTERISK y { Expr::BinaryExpression(Box::new(x), BinaryOp::Mul, Box::new(y)) }
       x OP_SLASH y { Expr::BinaryExpression(Box::new(x), BinaryOp::Div, Box::new(y)) }
}

simple_expr -> Expr
    = i:integer { Expr::Value(Value::Integer(i)) }
    / f:float { Expr::Value(Value::Float(f)) }
    / i:identifier { Expr::Identifier(i) }

integer -> i64
    = #quiet<_integer> / #expected("integer")

_integer -> i64
    = n:$([+-]?[0-9]+) __ { n.parse().unwrap() }

float -> f64
    = #quiet<_float> / #expected("integer")

_float -> f64
    = f:$([+-]?[0-9]+"."[0-9]+) __ { f.parse().unwrap() }

comma = "," __

identifier -> String
    = #quiet<_identifier> / #expected("identifier")

_identifier -> String
    = i:$([a-zA-Z][a-zA-Z0-9]*[!?]?) __ { i.to_string() }

type_annotation -> String
    = #quiet<_type_annotation> / #expected("type annotation")

_type_annotation -> String
    = OP_COLON i:$([a-zA-Z][a-zA-Z0-9]*[!?]?) __ { i.to_string() }

__ = whitespace*

whitespace = #quiet<[ \t]>

equals = #quiet<"=" __> / #expected("equals")

terminators = TERMINATOR+

TERMINATOR -> ()
    = "\n" __
    / ";" __

OP_PLUS = "+" __
OP_MINUS = "-" __
OP_ASTERISK = "*" __
OP_SLASH = "/" __
OP_COLON = ":" __

OPENING_BRACE = "{" __
CLOSING_BRACE = "}" __

keyword<E> = E __

VAR = keyword<"var">
VAL = keyword<"val">
