use ast::*;

pub program -> Vec<StatementNode>
    = __ terminators? s:statements { s }

pub statements -> Vec<StatementNode>
    = statement_node*

statement_node -> StatementNode
    = lpos:#position s:statement rpos:#position { StatementNode { pos: (lpos, rpos), data: s } }

statement -> Statement
    = s:if_statement { s }
    / l:loop_statement { l }
    / BREAK TERMINATOR { Statement::Break }
    / RETURN e:expr_node? TERMINATOR { Statement::Return(e) }
    / f:function_definition_node { Statement::Expression(f) }
    / a:assignment_statement { a }
    / v:variable_declaration { v }
    / e:expr_node TERMINATOR { Statement::Expression(e) }
    / b:block { b }
    / TERMINATOR { Statement::Empty }

assignment_statement -> Statement
    = lpos:#position i:identifier rpos:#position EQUALS e:expr_node TERMINATOR {
        Statement::Assignment(LhsExprNode { pos: (lpos, rpos), data: LhsExpr::Identifier(i) }, e)
    }

variable_declaration -> Statement
    = b:binding_type i:identifier EQUALS e:expr_node TERMINATOR {
        Statement::VariableDeclaration(
            Variable::Identifier(b, i), e
        )
     }

binding_type -> BindingType
    = VAR { BindingType::Mutable }

loop_statement -> Statement
    = LOOP lpos:#position b:block rpos:#position { Statement::Loop(Box::new(StatementNode { pos: (lpos, rpos), data: b })) }

if_statement -> Statement
    = IF e:expr_node lpos1:#position b1:block rpos1:#position ELSE lpos2:#position b2:block rpos2:#position {
        Statement::IfThenElse(
            e,
            Box::new(StatementNode { pos: (lpos1, rpos1), data: b1 }),
            Box::new(StatementNode { pos: (lpos2, rpos2), data: b2 }),
        )
    }
    / IF e:expr_node lpos:#position b:block rpos:#position { Statement::IfThen(e, Box::new(StatementNode { pos: (lpos, rpos), data: b })) }

block -> Statement
    = #quiet<_block> / #expected("block")

_block -> Statement
    = OPENING_BRACE terminators? s:statements terminators? CLOSING_BRACE { Statement::Block(s) }

function_definition_node -> ExprNode
    = lpos:#position f:function_definition rpos:#position { ExprNode { pos: (lpos, rpos), data: f } }

function_definition -> Expr
    = FN i:identifier? OPEN_PAREN params:param_list COMMA? CLOSE_PAREN lpos:#position body:block rpos:#position {
        Expr::FunctionDefinition(
            i,
            params,
            Box::new(StatementNode { pos: (lpos, rpos), data: body } ),
        )
    }

param_list -> Vec<String>
    = identifier ** COMMA

expr_node -> ExprNode
    = e:binary_expr_node { e }
    / s:simple_expr_node { s }

function_call_node -> ExprNode
    = lpos:#position f:function_call rpos:#position { ExprNode { pos: (lpos, rpos), data: f } }

function_call -> Expr
    = e:callable_expr_node OPEN_PAREN args:comma_args COMMA? CLOSE_PAREN {
        Expr::FunctionCall(Box::new(e), args)
    }

comma_args -> Vec<ExprNode>
    = expr_node ** COMMA

binary_expr_node -> ExprNode
    = lpos:#position e:binary_expr rpos:#position { ExprNode { pos: (lpos, rpos), data: e.data } }

binary_expr -> ExprNode = #infix<simple_expr_node> {
    #L x AND y { ExprNode { pos: (0, 0), data: Expr::BinaryLogicalExpression(Box::new(x), LogicalBinaryOp::LogicalAnd, Box::new(y)) } }
       x OR y { ExprNode { pos: (0, 0), data: Expr::BinaryLogicalExpression(Box::new(x), LogicalBinaryOp::LogicalOr, Box::new(y)) } }
    #L x OP_STRICT_EQUALS y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::StrictEquals, Box::new(y)) } }
    #L x OP_LESS_THAN y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::LessThan, Box::new(y)) } }
       x OP_LESS_THAN_OR_EQUAL y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::LessThanOrEqual, Box::new(y)) } }
       x OP_GREATER_THAN y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::GreaterThan, Box::new(y)) } }
       x OP_GREATER_THAN_OR_EQUAL y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::GreaterThanOrEqual, Box::new(y)) } }
    #L x OP_PLUS y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::Add, Box::new(y)) } }
       x OP_MINUS y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::Sub, Box::new(y)) } }
    #L x OP_ASTERISK y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::Mul, Box::new(y)) } }
       x OP_SLASH y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::Div, Box::new(y)) } }
       x OP_SLASH_SLASH y { ExprNode { pos: (0, 0), data: Expr::BinaryExpression(Box::new(x), BinaryOp::FloorDiv, Box::new(y)) } }
}

simple_expr_node -> ExprNode
    = lpos:#position e:simple_expr rpos:#position { ExprNode { pos: (lpos, rpos), data: e } }
    / OPEN_PAREN e:expr_node CLOSE_PAREN { e }
    / lpos:#position t:tuple rpos:#position { ExprNode { pos: (lpos, rpos), data: t } }

simple_expr -> Expr
    = OP_MINUS e:simple_expr_node { Expr::UnaryExpression(UnaryOp::Minus, Box::new(e)) }
    / NOT e:expr_node { Expr::UnaryLogicalExpression(LogicalUnaryOp::Not, Box::new(e)) }
    / l:literal { Expr::Literal(l) }
    / f:function_call { f }
    / f:function_definition { f }
    / i:identifier { Expr::Identifier(i) }

callable_expr_node -> ExprNode
    = lpos:#position e:callable_expr rpos:#position { ExprNode { pos: (lpos, rpos), data: e } }
    / OPEN_PAREN e:expr_node CLOSE_PAREN { e }

callable_expr -> Expr
    = i:identifier { Expr::Identifier(i) }
    // TODO: function call, support `foo()()`

literal -> Literal
    = f:float { Literal::Float(f) }
    / i:integer { Literal::Integer(i) }
    / b:boolean { Literal::Bool(b) }
    / s:doubleQuotedString { Literal::String(s) }

tuple -> Expr
    = #quiet<_tuple> / #expected("tuple")

_tuple -> Expr
    = OPEN_PAREN args:comma_args COMMA? CLOSE_PAREN {
        Expr::Tuple(args)
    }

doubleQuotedString -> String
    = #quiet<_doubleQuotedString> / #expected("string")

_doubleQuotedString -> String
    = '"' s:$([^"]*) '"' __ { s.to_owned() }

integer -> i64
    = #quiet<_integer> / #expected("number")

_integer -> i64
    = n:$([+-]?[0-9]+) __ { n.parse().unwrap() }

float -> f64
    = #quiet<_float> / #expected("number")

_float -> f64
    = f:$([+-]?[0-9]+"."[0-9]+) __ { f.parse().unwrap() }

boolean -> bool
    = #quiet<_boolean> / #expected("bool")

_boolean -> bool
    = "true" __ { true }
    / "false" __ { false }

identifier -> String
    = #quiet<_identifier> / #expected("identifier")

_identifier -> String
    = !reserved_identifier i:$([a-zA-Z_][a-zA-Z0-9_]*[!?]?) __ { i.to_string() }

__ = whitespace*

whitespace = #quiet<[ \t\n]>

EQUALS = #quiet<"=" __> / #expected("equals")

terminators = TERMINATOR+

TERMINATOR -> ()
    = ";" __

OP_PLUS = "+" __
OP_MINUS = "-" __
OP_ASTERISK = "*" __
OP_SLASH = "/" __
OP_SLASH_SLASH = "//" __
OP_COLON = ":" __
OP_LESS_THAN = "<" __
OP_GREATER_THAN = ">" __
OP_LESS_THAN_OR_EQUAL = "<=" __
OP_GREATER_THAN_OR_EQUAL = ">=" __

OP_STRICT_EQUALS = "==" __

OPENING_BRACE = "{" __
CLOSING_BRACE = "}" __
OPEN_PAREN = "(" __
CLOSE_PAREN = ")" __

COMMA = "," __

reserved_identifier = VAR
                    / IF
                    / ELSE
                    / AND
                    / OR
                    / NOT
                    / "true"
                    / "false"
                    / LOOP
                    / BREAK
                    / FN
                    / RETURN;

keyword<E> = E __

VAR = keyword<"var">
IF = keyword<"if">
ELSE = keyword<"else">
AND = keyword<"and">
OR = keyword<"or">
NOT = keyword<"not">
LOOP = keyword<"loop">
BREAK = keyword<"break">
FN = keyword<"fn">
RETURN = keyword<"return">
