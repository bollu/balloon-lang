use ast::*;

pub program -> Vec<Statement>
    = __ terminators? s:statements { s }

pub statements -> Vec<Statement>
    = statement*

statement -> Statement
    = s:if_statement { s }
    / a:assignment_statement { a }
    / v:variable_declaration { v }
    / e:expr TERMINATOR { Statement::Expression(e) }
    / b:block { b }
    / t:TERMINATOR { Statement::Empty }

assignment_statement -> Statement
    = i:identifier EQUALS e:expr TERMINATOR {
        Statement::Assignment(LhsExpr::Identifier(i), e)
    }

variable_declaration -> Statement
    = b:binding_type i:identifier EQUALS e:expr TERMINATOR {
        Statement::VariableDeclaration(
            Variable::Identifier(b, i), e
        )
     }

binding_type -> BindingType
    = VAR { BindingType::Mutable }

if_statement -> Statement
    = IF OPEN_PAREN e:expr CLOSE_PAREN b1:block ELSE b2:block { Statement::IfThenElse(e, Box::new(b1), Box::new(b2)) }
    / IF OPEN_PAREN e:expr CLOSE_PAREN b:block { Statement::IfThen(e, Box::new(b)) }

block -> Statement
    = #quiet<_block> / #expected("block")

_block -> Statement
    = OPENING_BRACE terminators? s:statements terminators? CLOSING_BRACE { Statement::Block(s) }

expr -> Expr
    = e:binary_expr { e }
    / s:simple_expr { s }
    / i:identifier { Expr::Identifier(i) }

binary_expr -> Expr = #infix<simple_expr> {
    #L x OP_LESS_THAN y { Expr::BinaryExpression(Box::new(x), BinaryOp::LessThan, Box::new(y)) }
       x OP_LESS_THAN_OR_EQUAL y { Expr::BinaryExpression(Box::new(x), BinaryOp::LessThanOrEqual, Box::new(y))}
       x OP_GREATER_THAN y { Expr::BinaryExpression(Box::new(x), BinaryOp::GreaterThan, Box::new(y)) }
       x OP_GREATER_THAN_OR_EQUAL y { Expr::BinaryExpression(Box::new(x), BinaryOp::GreaterThanOrEqual, Box::new(y)) }
    #L x OP_PLUS y { Expr::BinaryExpression(Box::new(x), BinaryOp::Add, Box::new(y)) }
       x OP_MINUS y { Expr::BinaryExpression(Box::new(x), BinaryOp::Sub, Box::new(y)) }
    #L x OP_ASTERISK y { Expr::BinaryExpression(Box::new(x), BinaryOp::Mul, Box::new(y)) }
       x OP_SLASH y { Expr::BinaryExpression(Box::new(x), BinaryOp::Div, Box::new(y)) }
       x OP_SLASH_SLASH y { Expr::BinaryExpression(Box::new(x), BinaryOp::FloorDiv, Box::new(y)) }
}

simple_expr -> Expr
    = l:literal { Expr::Literal(l) }
    / i:identifier { Expr::Identifier(i) }
    / OPEN_PAREN e:expr CLOSE_PAREN { e }

literal -> Literal
    = f:float { Literal::Float(f) }
    / i:integer { Literal::Integer(i) }
    / b:boolean { Literal::Bool(b) }

integer -> i64
    = #quiet<_integer> / #expected("number")

_integer -> i64
    = n:$([+-]?[0-9]+) __ { n.parse().unwrap() }

float -> f64
    = #quiet<_float> / #expected("number")

_float -> f64
    = f:$([+-]?[0-9]+"."[0-9]+) __ { f.parse().unwrap() }

boolean -> bool
    = #quiet<_boolean> / #expected("bool")

_boolean -> bool
    = "true" __ { true }
    / "false" __ { false }

identifier -> String
    = #quiet<_identifier> / #expected("identifier")

_identifier -> String
    = i:$([a-zA-Z][a-zA-Z0-9]*[!?]?) __ { i.to_string() }

__ = whitespace*

whitespace = #quiet<[ \t\n]>

EQUALS = #quiet<"=" __> / #expected("equals")

terminators = TERMINATOR+

TERMINATOR -> ()
    = ";" __

OP_PLUS = "+" __
OP_MINUS = "-" __
OP_ASTERISK = "*" __
OP_SLASH = "/" __
OP_SLASH_SLASH = "//" __
OP_COLON = ":" __
OP_LESS_THAN = "<" __
OP_GREATER_THAN = ">" __
OP_LESS_THAN_OR_EQUAL = "<=" __
OP_GREATER_THAN_OR_EQUAL = ">=" __

OPENING_BRACE = "{" __
CLOSING_BRACE = "}" __
OPEN_PAREN = "(" __
CLOSE_PAREN = ")" __

keyword<E> = E __

VAR = keyword<"var">
IF = keyword<"if">
ELSE = keyword<"else">
