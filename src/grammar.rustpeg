use ast::*;

pub program -> Vec<Statement>
    = __ s:statements { s }

pub statements -> Vec<Statement>
    = terminators? sx:statement terminators? s:statements { let mut sc = s.to_vec(); sc.insert(0, sx); sc }
    / terminators? sx:statement terminators? { let mut v = vec![sx]; v }

pub statement -> Statement
    = a:assignment_statement { a }
    / v:variable_declaration { v }

assignment_statement -> Statement
    = i:identifier equals e:expr {
        Statement::Assignment(LhsExpr::Identifier(i), e)
    }

variable_declaration -> Statement
    = b:binding i:identifier a:type_annotation? equals e:expr {
        match a {
            Some(t) => Statement::VariableDeclaration(
                Variable::IdentifierWithType(b, i, t), e
            ),
            None => Statement::VariableDeclaration(
                Variable::Identifier(b, i), e
            )
        }
     }

binding -> Binding
    = VAR { Binding::Mutable }
    / VAL { Binding::Immutable }

pub expr -> Expr
    = e:binary_expr { e }
    / n:number { Expr::Number(n) }
    / i:identifier t:type_annotation { Expr::IdentifierWithType(i, t) }
    / i:identifier { Expr::Identifier(i) }

binary_expr -> Expr = #infix<simple_expr> {
    #L x OP_PLUS y { Expr::BinaryExpression(Box::new(x), BinaryOp::Add, Box::new(y)) }
       x OP_MINUS y { Expr::BinaryExpression(Box::new(x), BinaryOp::Sub, Box::new(y)) }
    #L x OP_ASTERISK y { Expr::BinaryExpression(Box::new(x), BinaryOp::Mul, Box::new(y)) }
       x OP_SLASH y { Expr::BinaryExpression(Box::new(x), BinaryOp::Div, Box::new(y)) }
}

simple_expr -> Expr
    = n:number { Expr::Number(n) }
    / i:identifier { Expr::Identifier(i) }

number -> i64
    = #quiet<_number> / #expected("number")

_number -> i64
    = n:$([0-9]+) __ { n.parse().unwrap() }

comma = "," __

identifier -> String
    = #quiet<_identifier> / #expected("identifier")

_identifier -> String
    = i:$([a-zA-Z][a-zA-Z0-9]*[!?]?) __ { i.to_string() }

type_annotation -> String
    = #quiet<_type_annotation> / #expected("type annotation")

_type_annotation -> String
    = OP_COLON i:$([a-zA-Z][a-zA-Z0-9]*[!?]?) __ { i.to_string() }

__ = whitespace*

whitespace = #quiet<[ \t]>

equals = #quiet<"=" __> / #expected("equals")

terminators = TERMINATOR+

TERMINATOR -> ()
    = "\n" __
    / ";" __

OP_PLUS = "+" __
OP_MINUS = "-" __
OP_ASTERISK = "*" __
OP_SLASH = "/" __
OP_COLON = ":" __

keyword<E> = E __

VAR = keyword<"var">
VAL = keyword<"val">
